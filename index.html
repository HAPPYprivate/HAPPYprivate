<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<link rel="icon" href="icon.png" type="image/png">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üîí Access blocked</title>

<style>
  :root{
    --bg1: #020007;
    --bg2: #060014;
    --accent1: #9b56ff;
    --muted: #dcd4ff;
  }

  html,body{height:100%;margin:0;padding:0;font-family:Inter, "Segoe UI", Roboto, sans-serif;overflow:hidden;background:var(--bg1);color:var(--muted)}

  .stage{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    text-align:center;
    background: linear-gradient(180deg, var(--bg2), var(--bg1));
  }

  /* canvas overlays */
  canvas.bg-canvas, canvas.meteor-canvas {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
    pointer-events:none;
    z-index:2;
  }

  /* logo */
  .logo {
    position: fixed;
    left: 18px;
    top: 18px;
    width: 56px;
    height: 56px;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    box-shadow: 0 6px 30px rgba(90,10,150,0.12), inset 0 1px 0 rgba(255,255,255,0.02);
    border:1px solid rgba(150,60,255,0.06);
    z-index:6;
  }
  .logo img{width:44px;height:44px;object-fit:contain;border-radius:8px;}

  /* content */
  .card {
    z-index:5;
    max-width:920px;
    width:92%;
    padding:36px 40px;
    border-radius:16px;
    background: linear-gradient(180deg, rgba(12,6,25,0.55), rgba(8,2,18,0.35));
    border:1px solid rgba(120,40,255,0.06);
    box-shadow: 0 10px 60px rgba(40,10,80,0.45);
    backdrop-filter: blur(8px) saturate(1.05);
    display:flex;
    flex-direction:column;
    gap:18px;
    align-items:center;
  }

  h1 {
    margin:0;
    font-size:36px;
    letter-spacing:0.6px;
    color:var(--accent1);
    text-shadow: 0 6px 24px rgba(120,40,255,0.14), 0 1px 0 rgba(255,255,255,0.02);
  }

  .note {
    color: #e9e3ff;
    opacity:0.9;
    font-size:16px;
    max-width:780px;
    line-height:1.45;
  }

  /* static small star layer (DOM twinkle) */
  .stars {
    position:absolute;
    inset:0;
    z-index:3;
    pointer-events:none;
  }
  .star {
    position:absolute;
    width:2px;
    height:2px;
    background:rgba(255,255,255,0.9);
    border-radius:50%;
    box-shadow:0 0 6px rgba(160,140,255,0.12);
    opacity:0.85;
    transform:translate3d(0,0,0);
    animation: twinkle 6s infinite ease-in-out;
  }
  @keyframes twinkle {
    0%{ opacity:0.25; transform:scale(1) }
    50%{ opacity:1; transform:scale(1.5) }
    100%{ opacity:0.25; transform:scale(1) }
  }

  .footer {
    position:fixed;
    right:12px;
    bottom:12px;
    color:rgba(230,220,255,0.28);
    font-size:12px;
    z-index:6;
  }

  @media (max-width:520px){
    h1{font-size:28px}
    .card{padding:20px}
  }
</style>
</head>
<body>
  <div class="stage">
    <canvas class="bg-canvas" id="bgCanvas"></canvas>
    <div class="stars" id="stars"></div>
    <canvas class="meteor-canvas" id="meteorCanvas"></canvas>

    <div class="logo" aria-hidden="true">
      <img src="icon.png" alt="logo" />
    </div>

    <div class="card" role="main" aria-labelledby="page-title">
      <h1 id="page-title">üîí Truy c·∫≠p b·ªã ch·∫∑n</h1>
      <div class="note">Trang n√†y ch·ªâ hi·ªÉn th·ªã giao di·ªán. Vui l√≤ng s·ª≠ d·ª•ng h·ªá th·ªëng ch√≠nh th·ª©c ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu.</div>
    </div>

    <div class="footer">HAPPY¬∑script</div>
  </div>

<script>
/* ============================
   Small twinkling stars (DOM)
   ============================ */
(function makeStars(){
  const container = document.getElementById('stars');
  const count = 160;
  const rnd = (min,max)=>Math.random()*(max-min)+min;
  for(let i=0;i<count;i++){
    const s=document.createElement('div');
    s.className='star';
    const x=rnd(0,100), y=rnd(0,100);
    const size=rnd(0.6,2.2);
    s.style.left = x + 'vw';
    s.style.top  = y + 'vh';
    s.style.width = size + 'px';
    s.style.height = size + 'px';
    s.style.opacity = rnd(0.12,0.95);
    s.style.animationDuration = (rnd(4,9)).toFixed(2) + 's';
    s.style.animationDelay = (rnd(0,6)).toFixed(2) + 's';
    container.appendChild(s);
  }
})();

/* ============================
   Background Nebula (2 soft purple blobs, animated)
   - Replaces static blobs; move slowly and fade in/out
   ============================ */
(function NebulaBG(){
  const c = document.getElementById('bgCanvas');
  const ctx = c.getContext('2d');
  let w=0,h=0,DPR=Math.max(1,window.devicePixelRatio||1);
  function resize(){
    w = innerWidth; h = innerHeight;
    c.width = Math.floor(w*DPR);
    c.height = Math.floor(h*DPR);
    c.style.width = w+'px';
    c.style.height = h+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize); resize();

  const ENABLE_NEBULA = true;
  // Two nebula blobs with independent slow motion
  const blobs = [
    { xPct: 0.12, yPct: 0.22, radius: Math.max(600, Math.min(900, Math.max(w,h)/1.2)), phase: Math.random()*Math.PI*2, speed: 0.00012, baseAlpha: 0.18 },
    { xPct: 0.86, yPct: 0.78, radius: Math.max(500, Math.min(900, Math.max(w,h)/1.6)), phase: Math.random()*Math.PI*2, speed: 0.00008, baseAlpha: 0.14 }
  ];

  function drawNebula(t){
    if(!ENABLE_NEBULA) return;
    ctx.clearRect(0,0,w,h);
    // subtle vignette
    const vign = ctx.createRadialGradient(w*0.5, h*0.5, 0, w*0.5, h*0.5, Math.max(w,h));
    vign.addColorStop(0, 'rgba(10,4,20,0.10)');
    vign.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = vign;
    ctx.fillRect(0,0,w,h);

    blobs.forEach((b,idx)=>{
      const time = t * 0.0006;
      // slow noise-like motion using sines
      const dx = Math.cos(b.phase + time * (0.3 + idx*0.15)) * (w*0.04);
      const dy = Math.sin(b.phase*1.3 + time * (0.18 + idx*0.07)) * (h*0.03);
      const cx = Math.floor(w * b.xPct + dx);
      const cy = Math.floor(h * b.yPct + dy);
      const r = b.radius * (0.9 + 0.12 * Math.sin(b.phase*0.7 + time*0.6));
      const alpha = b.baseAlpha * (0.6 + 0.4 * Math.sin(b.phase*0.9 + time*0.9));
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      g.addColorStop(0, `rgba(150,70,255,${(alpha*0.95).toFixed(3)})`);
      g.addColorStop(0.25, `rgba(110,30,220,${(alpha*0.6).toFixed(3)})`);
      g.addColorStop(0.6, `rgba(60,0,120,${(alpha*0.22).toFixed(3)})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = g;
      ctx.fillRect(cx - r*1.05, cy - r*1.05, r*2.1, r*2.1);
      ctx.globalCompositeOperation = 'source-over';
    });
  }

  let start = performance.now();
  function frame(now){
    drawNebula(now - start);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();

/* ============================
   Meteor system using canvas (improved smooth trail)
   - smoother quadratic trail, guaranteed crossing, rare early fade
   ============================ */

(function MeteorEngine(){
  const canvas = document.getElementById('meteorCanvas');
  const ctx = canvas.getContext('2d');
  let width = 0, height = 0, DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize(){
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  const reduced = (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);

  class Meteor {
    constructor(){
      const startFromRight = Math.random() > 0.5;
      const band = Math.random() * 0.35; // top band fraction
      this.y = Math.random() * height * band + height * 0.02;
      if(startFromRight){
        this.x = width + Math.random()*160;
        // angle to go left-down across screen
        this.angle = (200 + Math.random()*80) * Math.PI/180;
      } else {
        this.x = -Math.random()*160;
        this.angle = (280 + Math.random()*80) * Math.PI/180;
      }

      // speed (px/ms) tuned for smooth crossing
      this.speed = (Math.random()*1100 + 700) / 1000; // 0.7 - 1.8 px/ms
      this.size = Math.random()*1.6 + 1.8;
      this.trail = []; // smoothed points
      // target trail length in px
      this.trailLen = Math.random()*300 + 300; // 300 - 600px
      this.life = 0;
      this.alpha = 1;
      this.hue = 255; // purple glow base
      // will the meteor fade early? rare
      this.earlyFade = Math.random() < 0.05; // 5% chance
      this.fadeStartAfter = this.earlyFade ? (Math.random()*0.4 + 0.25) : 1.1; // fraction of crossing
      // record starting position
      this.started = false;
    }

    update(dt){
      // move
      const dx = Math.cos(this.angle) * this.speed * dt;
      const dy = Math.sin(this.angle) * this.speed * dt;
      this.x += dx; this.y += dy;
      this.life += dt;

      // push current head into trail
      this.trail.push({x:this.x, y:this.y, t: performance.now()});
      // trim trail by pixel length: remove oldest until approximate length <= trailLen
      // approximate by keeping last N points and trimming if too long
      while(this.trail.length > 4){
        const first = this.trail[0];
        const last = this.trail[this.trail.length-1];
        const dxl = last.x - first.x;
        const dyl = last.y - first.y;
        const approxLen = Math.hypot(dxl, dyl);
        if(approxLen > this.trailLen) break;
        // if approxLen <= trailLen but too many points, keep sampling
        if(this.trail.length > 200) this.trail.shift();
        else break;
      }

      // early fade logic (rare)
      if(this.earlyFade){
        // find fraction of screen crossed approximate
        const frac = Math.abs(this.x - width/2) / (width/2 + 200);
        if(frac > this.fadeStartAfter) this.alpha = Math.max(0, 1 - (frac - this.fadeStartAfter) * 1.8);
      }

      // clamp alpha to 0..1
            // fade out khi g·∫ßn ra kh·ªèi m√†n
      if (this.trail.length > 2) {
          const first = this.trail[0];
          const last = this.trail[this.trail.length - 1];
          const dx = last.x - first.x;
          const dy = last.y - first.y;
          const dist = Math.hypot(dx, dy);

          if (dist > this.fadeOutDist) {
              const f = (dist - this.fadeOutDist) / this.fadeOutDist;
              this.alpha = Math.max(0, 0.92 - f * 1.4); // m·ªù d·∫ßn
          }
      }

      this.alpha = Math.max(0, Math.min(1, this.alpha));
    }

    // draw smooth trail using quadratic curve interpolation
    draw(ctx){
      if(this.trail.length < 2) return;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      // draw glow layers (wider, soft)
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // create path smoothed via quadratic curve
      ctx.beginPath();
      const pts = this.trail;
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length-1;i++){
        const xc = (pts[i].x + pts[i+1].x)/2;
        const yc = (pts[i].y + pts[i+1].y)/2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
      }
      // final segment
      const last = pts[pts.length-1];
      ctx.lineWidth = (this.size * 8) * this.alpha;
      // wide soft glow
      const gradGlow = ctx.createLinearGradient(pts[0].x, pts[0].y, last.x, last.y);
      gradGlow.addColorStop(0, `rgba(180,120,255,${0.04*this.alpha})`);
      gradGlow.addColorStop(0.6, `rgba(200,130,255,${0.10*this.alpha})`);
      gradGlow.addColorStop(1, `rgba(255,255,255,${0.18*this.alpha})`);
      ctx.strokeStyle = gradGlow;
      ctx.stroke();

      // mid glow
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length-1;i++){
        const xc = (pts[i].x + pts[i+1].x)/2;
        const yc = (pts[i].y + pts[i+1].y)/2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
      }
      ctx.lineWidth = (this.size * 4) * this.alpha;
      const gradMid = ctx.createLinearGradient(pts[0].x, pts[0].y, last.x, last.y);
      gradMid.addColorStop(0, `rgba(220,180,255,${0.10*this.alpha})`);
      gradMid.addColorStop(0.7, `rgba(255,240,255,${0.7*this.alpha})`);
      gradMid.addColorStop(1, `rgba(255,255,255,${1.0*this.alpha})`);
      ctx.strokeStyle = gradMid;
      ctx.stroke();

      // sharp core line (thin bright)
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length-1;i++){
        const xc = (pts[i].x + pts[i+1].x)/2;
        const yc = (pts[i].y + pts[i+1].y)/2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
      }
      ctx.lineWidth = (this.size * 1.0) * this.alpha;
      ctx.strokeStyle = `rgba(255,255,255,${0.98*this.alpha})`;
      ctx.stroke();

      // draw head
      const h = last;
      const rad = this.size * 2.0;
      const rg = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, rad*2.5);
      rg.addColorStop(0, `rgba(255,255,255,${1*this.alpha})`);
      rg.addColorStop(0.15, `rgba(240,220,255,${0.85*this.alpha})`);
      rg.addColorStop(0.35, `rgba(200,150,255,${0.62*this.alpha})`);
      rg.addColorStop(1, `rgba(120,30,255,0)`);
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(h.x, h.y, rad*1.6, 0, Math.PI*2);
      ctx.fill();

      // sharp core dot
      ctx.fillStyle = `rgba(255,255,255,${0.98*this.alpha})`;
      ctx.beginPath();
      ctx.arc(h.x, h.y, this.size, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    isDead(){
      // dead only when fully outside viewport (plus margin)
      if(this.x < -220 || this.x > width + 220 || this.y > height + 220 || this.y < -220) return true;
      return false;
    }
  }

  const meteors = [];

  function spawnMeteor(){
    if(reduced) return;
    meteors.push(new Meteor());
  }

  function schedule(){
    const next = Math.random()*7000 + 1800; // 1.8s - 8.8s
    setTimeout(()=>{
      const group = Math.random() > 0.68 ? Math.floor(Math.random()*3)+1 : 1;
      for(let i=0;i<group;i++) setTimeout(spawnMeteor, i*140);
      schedule();
    }, next);
  }
  schedule();

  // animation loop
  let last = performance.now();
  function loop(now){
    const dt = now - last;
    last = now;
    // clear canvas
    ctx.clearRect(0,0,width,height);
    // draw each meteor
    for(let i=meteors.length-1;i>=0;i--){
      const m = meteors[i];
      m.update(dt);
      m.draw(ctx);
      if(m.isDead()) meteors.splice(i,1);
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();

/* Accessibility: respect reduced-motion */
if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
  console.log('prefers-reduced-motion: reduce ‚Äî animations reduced.');
}
</script>
</body>
</html>
